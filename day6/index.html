<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AoC 2024 Day 6.2 — Viewer</title>
    <style>
      :root {
        --cell-size: 1px;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 16px;
        line-height: 1.4;
        background-color: grey;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol";
      }
      h1 {
        margin: 0 0 12px;
        font-size: 20px;
      }
      #controls {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: start;
        margin-bottom: 12px;
      }
      textarea {
        width: 100%;
        height: 240px;
        resize: vertical;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 14px;
        padding: 8px;
        border: 1px solid #d0d7de;
        border-radius: 8px;
      }
      #actions {
        display: grid;
        gap: 8px;
      }
      button {
        padding: 8px 12px;
        border: 1px solid #d0d7de;
        border-radius: 8px;
        background: #f6f8fa;
        cursor: pointer;
        font-weight: 600;
        margin: 4px;
      }
      button:active {
        transform: translateY(1px);
      }
      label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 14px;
      }
      .viewport {
        height: 90vh; /* visible window for the grid */
        overflow: auto; /* only this container scrolls */
        position: relative;
        contain: content;
        will-change: scroll-position;
        border: 1px solid #d0d7de;
        border-radius: 8px;
        background: white;
        padding: 8px;
        margin-top: 8px;
      }
      .grid-wrapper {
        display: inline-grid;
        grid-template-columns: var(--cell-size) repeat(
            auto-fit,
            var(--cell-size)
          );
        gap: 2px;
        align-items: center;
        justify-content: start;
      }
      .axis-label {
        width: var(--cell-size);
        height: var(--cell-size);
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 14px;
        font-weight: 600;
        user-select: none;
        color: #6b7280;
      }
      #grid {
        display: contents;
      }
      .cell {
        width: var(--cell-size);
        height: var(--cell-size);
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 16px;
        user-select: none;
        border: 1px solid #e5e7eb;
        border-radius: 4px;
        margin: 4px;
      }
      .cell.secondary {
        outline: 2px solid #67eb25;
        outline-offset: 0;
        color: #245ca5;
      }
      .cell.primary {
        outline: 4px solid #eb2525;
        outline-offset: 0;
        background: #dbeafe;
      }
      .no-borders .cell {
        border: none;
      }
      .newline {
        font-style: italic;
        color: #9ca3af;
        user-select: none;
      }
      .newline::before {
        content: "\\\n";
      }
      .obstacle {
        /* Dark base + high-contrast outline so obstacles pop even at 1px cells */
        background-color: #2f2f2f;
        color: #262729;
        outline: 3px solid #111; /* thick outline independent of --cell-size */
        outline-offset: 0;
        /* Subtle hatch pattern for texture at larger cell sizes, still noticeable when tiny */
        background-image: repeating-linear-gradient(
          45deg,
          rgba(255, 255, 255, 0.3) 0 2px,
          transparent 2px 6px
        );
      }
      #status {
        margin-top: 8px;
        color: #6b7280;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <h1>AoC 2024 Day 6.2</h1>

    <div style="display: flex">
      <textarea
        id="input"
        style="width: 25%; height: 200px"
        placeholder="paste input here"
      ></textarea>
      <button style="align-self: center" id="resetButton" onclick="setup()">
        set grid
      </button>

      <div style="display: flex; flex-direction: column; width: 94px">
        <button id="stepButton" style="height: 50%" onclick="togglePlayPause()">
          play
        </button>
        <button id="playButton" style="height: 50%" onclick="takeStep(true)">
          step
        </button>
      </div>
    </div>

    <div
      id="sliders"
      style="display: flex; align-items: center; gap: 16px; margin-top: 8px"
    >
      <label for="cellSizeSlider">cell size</label>
      <div style="display: flex; align-items: center; gap: 8px">
        <button id="decCellSize" title="smaller" type="button">◀︎</button>
        <input
          id="cellSizeSlider"
          type="range"
          min="1"
          max="32"
          value="4"
          step="1"
        />
        <button id="incCellSize" title="larger" type="button">▶︎</button>
        <span
          id="cellSizeValue"
          style="font-family: monospace; min-width: 32px; text-align: right"
          >4</span
        >
      </div>
      <label for="coolingSlider"
        >cooling (ms)
        <input
          id="coolingSlider"
          type="range"
          min="2000"
          max="60000"
          value="20000"
          step="1000"
        />
      </label>
      <span id="coolingValue" style="font-family: monospace">20000</span>
    </div>

    <div id="counter">1</div>

    <div id="viewport" class="viewport">
      <div id="root"></div>
    </div>

    <script>
      const FRAME_RATE = 3;
      const EMPTY = "";
      // Heat coloring constants and helpers
      window.HEAT_WINDOW_MS = 20000; // how long it takes to cool from red -> blue
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      const heatColor = (ageMs) => {
        const t = clamp(ageMs / HEAT_WINDOW_MS, 0, 1);
        // Hue: 0 (red) -> 260 (purple/blue); keep high saturation for vivid color
        const hue = 260 * t; // 0 is red (just visited), 260 is violet/blue (oldest)
        const sat = 90;
        const light = 55;
        return `hsl(${hue} ${sat}% ${light}%)`;
      };
      const isVisited = (p) => typeof p?.z === "number" && p.z > 0;
      const $ = (sel) => document.querySelector(sel);
      const rootEl = $("#root");
      const inputEl = $("#input");
      const counterEl = $("#counter");
      const viewportEl = $("#viewport");
      const cellSizeSlider = $("#cellSizeSlider");
      const coolingSlider = $("#coolingSlider");
      const coolingValueEl = $("#coolingValue");
      const decCellSizeBtn = $("#decCellSize");
      const incCellSizeBtn = $("#incCellSize");
      const cellSizeValueEl = $("#cellSizeValue");

      const savedCellSize = Number(localStorage.getItem("cellSize")) || 4;
      const savedCooling = Number(localStorage.getItem("coolingMs")) || 20000;
      cellSizeSlider.value = String(savedCellSize);
      coolingSlider.value = String(savedCooling);
      cellSizeValueEl.textContent = String(savedCellSize);
      coolingValueEl.textContent = String(savedCooling);
      document.documentElement.style.setProperty(
        "--cell-size",
        `${savedCellSize}px`
      );
      window.HEAT_WINDOW_MS = savedCooling;

      cellSizeSlider?.addEventListener("input", (e) => {
        const size = Number(e.target.value);
        document.documentElement.style.setProperty("--cell-size", `${size}px`);
        localStorage.setItem("cellSize", String(size));
        if (cellSizeValueEl) cellSizeValueEl.textContent = String(size);
      });

      coolingSlider?.addEventListener("input", (e) => {
        const val = Number(e.target.value);
        window.HEAT_WINDOW_MS = val;
        coolingValueEl.textContent = String(val);
        localStorage.setItem("coolingMs", String(val));
      });

      const bumpCellSize = (delta) => {
        const curr = Number(cellSizeSlider.value);
        const next = Math.min(32, Math.max(1, curr + delta));
        if (next !== curr) {
          cellSizeSlider.value = String(next);
          cellSizeSlider.dispatchEvent(new Event("input", { bubbles: true }));
        }
      };
      decCellSizeBtn?.addEventListener("click", () => bumpCellSize(-1));
      incCellSizeBtn?.addEventListener("click", () => bumpCellSize(1));

      // Single-loop controller to avoid multiple concurrent animation loops
      const loop = {
        timerId: null,
        rafId: null,
        pending: false,
        play: () => {
          scheduleNext(getGrid());
          $("#stepButton").innerHTML = "pause";
        },
        pause: () => {
          cancelLoop();
          $("#stepButton").innerHTML = "play";
        },
      };

      const togglePlayPause = () => {
        if (loop.timerId || loop.rafId) {
          loop.pause();
        } else {
          loop.play();
        }
      };

      const cancelLoop = () => {
        if (loop.timerId) {
          clearTimeout(loop.timerId);
          loop.timerId = null;
        }
        if (loop.rafId) {
          cancelAnimationFrame(loop.rafId);
          loop.rafId = null;
        }
        loop.pending = false;
      };

      const scheduleNext = (grid) => {
        // Prevent stacking multiple timeouts/RAFs
        if (loop.pending) return;
        loop.pending = true;
        // loop.timerId = setTimeout(() => {
        incrementCounter(grid);
        const next = makeMove(grid);
        saveGrid(next);
        loop.rafId = requestAnimationFrame(() => {
          loop.pending = false;
          renderGrid(next);
        });
        // }, FRAME_RATE);
      };

      let cellEls = null; // Map key: `${row}:${col}` -> element
      let gridDims = { rows: 0, cols: 0 };

      const ensureDOMForGrid = (grid) => {
        const rows = Math.max(...grid.map((p) => p.row)) + 1;
        const cols = Math.max(...grid.map((p) => p.col)) + 1;
        if (cellEls && gridDims.rows === rows && gridDims.cols === cols) return;

        rootEl.innerHTML = "";
        cellEls = new Map();
        gridDims = { rows, cols };

        let rowEl = document.createElement("div");
        rowEl.style = "display: flex;";

        for (let i = 0; i < grid.length; i++) {
          const curr = grid[i];
          const nextIndex = i + 1;
          const next =
            nextIndex < grid.length ? grid[nextIndex] : { row: undefined };

          const cell = document.createElement("div");
          cell.className = "cell";
          cellEls.set(`${curr.row}:${curr.col}`, cell);
          rowEl.appendChild(cell);

          if (curr.row !== next.row) {
            rootEl.appendChild(rowEl);
            rowEl = document.createElement("div");
            rowEl.style = "display: flex;";
          }
        }
      };

      const renderGrid = (grid) => {
        if (!grid || !grid.length) {
          rootEl.innerHTML = EMPTY;
          return;
        }

        ensureDOMForGrid(grid);

        let activeCell = null;

        for (let i = 0; i < grid.length; i++) {
          const curr = grid[i];
          const el = cellEls.get(`${curr.row}:${curr.col}`);

          // Reset classes/styles (minimal touches)
          el.className = "cell";
          el.removeAttribute("data-age");
          el.style.outline = "";
          el.style.backgroundColor = "";

          // Primary marker (agent)
          if (curr.value !== EMPTY && curr.value !== "#") {
            el.classList.add("primary");
            activeCell = el;
          }
          // Obstacle
          if (curr.value === "#") {
            el.classList.add("obstacle");
          }
          // Heat color
          if (isVisited(curr) && curr.value !== "#") {
            const age = Date.now() - curr.z;
            const color = heatColor(age);
            el.style.backgroundColor = color;
            el.style.outline = `3px solid ${color}`;
            el.setAttribute("data-age", String(age));
          }
        }

        if (getPosition(grid)) {
          scheduleNext(grid);
        }

        // Center vertically using the active cell's offset
        if (activeCell && viewportEl) {
          const target =
            activeCell.offsetTop -
            (viewportEl.clientHeight / 2 - activeCell.offsetHeight / 2);
          const delta = Math.abs(viewportEl.scrollTop - target);
          if (delta > 2) viewportEl.scrollTop = target;
        }
      };

      const incrementCounter = (grid) =>
        (counterEl.innerHTML = grid.reduce(
          (sum, p) => sum + (isVisited(p) ? 1 : 0),
          0
        ));

      const getGrid = () =>
        JSON.parse(localStorage.getItem("grid")) ?? parseInput(inputEl.value);
      const saveGrid = (grid) =>
        localStorage.setItem("grid", JSON.stringify(grid));

      const takeStep = (cancel = false) => {
        cancelLoop();
        const grid = makeMove(getGrid());
        saveGrid(grid);
        renderGrid(grid);
        incrementCounter(grid);
        cancel && cancelLoop();
        if (!loop.rafId && !loop.timerId) $("#stepButton").innerHTML = "play";
        else $("#stepButton").innerHTML = "pause";
      };

      const makeMove = (grid) => {
        const position = getPosition(grid) ?? {};
        const nextPosition = getNextPosition(grid, position) ?? position;

        if (nextPosition?.value === "#") {
          switch (position.value) {
            case "^":
              return executeMove(position, position, grid, ">");
            case ">":
              return executeMove(position, position, grid, "v");
            case "v":
              return executeMove(position, position, grid, "<");
            case "<":
              return executeMove(position, position, grid, "^");
            default:
              return executeMove(position, position, grid, EMPTY);
          }
        }
        return executeMove(
          position,
          nextPosition,
          grid,
          position?.value ?? EMPTY
        );
      };

      const executeMove = (position, nextPosition, grid, value) => {
        return grid.map((p) =>
          p.col === nextPosition?.col && p.row === nextPosition.row
            ? { ...nextPosition, value, z: Date.now() }
            : p.col === position.col && p.row === position.row
            ? { ...p, value: EMPTY }
            : p.value === "."
            ? { ...p, value: EMPTY }
            : p
        );
      };

      const getPosition = (grid) => {
        return grid.find(
          (p) =>
            p.value === "^" ||
            p.value === "v" ||
            p.value === "<" ||
            p.value === ">"
        );
      };

      const getNextPosition = (grid, position) => {
        let temp = { ...position };
        switch (position.value) {
          case "<":
            temp = {
              ...position,
              col: position.col - 1,
            };
            break;
          case "^":
            temp = {
              ...position,
              row: position.row - 1,
            };
            break;
          case "v":
            temp = {
              ...position,
              row: position.row + 1,
            };
            break;
          case ">":
            temp = {
              ...position,
              col: position.col + 1,
            };
            break;
          default:
            return null;
        }

        return {
          ...temp,
          value: grid.find((p) => p.row === temp.row && p.col === temp.col)
            ?.value,
        };
      };

      const parseInput = (text) => {
        const grid = [[]];
        const lines = text.split("\n");
        for (let row = 0; row < lines.length; row++) {
          grid[row] = [];
          for (let col = 0; col < lines[row].length; col++) {
            grid[row][col] = {
              col,
              row,
              value: lines[row][col],
            };
          }
        }

        localStorage.setItem("initGrid", text);
        return grid.flat();
      };

      window.addEventListener("DOMContentLoaded", () => {
        const grid = getGrid();
        if (grid !== null) {
          inputEl.textContent = localStorage.getItem("initGrid");
          renderGrid(grid);
        } else if (inputEl.value.trim()) {
          setup();
        }
      });

      const setup = () => {
        cancelLoop();
        counterEl.innerHTML = 1;
        const newGrid = parseInput(inputEl.value);
        cellEls = null;
        gridDims = { rows: 0, cols: 0 };
        saveGrid(
          newGrid.map((p) => (p.value === "^" ? { ...p, z: Date.now() } : p))
        );
        renderGrid(newGrid);
        cancelLoop();
      };
    </script>
  </body>
</html>
